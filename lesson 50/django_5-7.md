# Django ORM

Итак, если Вы рассматриваете учебный пример приложения интервального повторения карточек, то, вероятно, вы остановились на вот такой БД.

```sql
--
-- Файл сгенерирован с помощью SQLiteStudio v3.4.4 в Вт фев 27 18:42:32 2024
--
-- Использованная кодировка текста: System
--
PRAGMA foreign_keys = off;
BEGIN TRANSACTION;

-- Таблица: Cards
CREATE TABLE IF NOT EXISTS Cards (
    CardID INTEGER PRIMARY KEY AUTOINCREMENT,
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    user_id INTEGER DEFAULT(1),
    upload_date DATETIME DEFAULT(datetime('now')),
    views INTEGER DEFAULT(0),
    adds INTEGER DEFAULT(0),
    FOREIGN KEY (user_id) REFERENCES Users(UserID)
);

-- Таблица: Users
CREATE TABLE IF NOT EXISTS Users (
    UserID INTEGER PRIMARY KEY AUTOINCREMENT,
    FirstName TEXT NOT NULL
);

COMMIT TRANSACTION;
PRAGMA foreign_keys = on;

```
Однако, в будущем, для дальнейшей работы, её необходимо будет расширить это.


Для соответствия вашим требованиям и интеграции данных, необходимых для шаблонов Django, мы внесем изменения и добавим таблицы для категорий и тегов, а также таблицу связи многие-ко-многим для карточек и тегов. Также добавим поля для категорий в таблице `Cards` и обновим ограничения для обеспечения целостности данных при удалении и обновлении.

```sql
PRAGMA foreign_keys = off;
BEGIN TRANSACTION;

-- Таблица: Users
CREATE TABLE IF NOT EXISTS Users (
    UserID INTEGER PRIMARY KEY AUTOINCREMENT,
    FirstName TEXT NOT NULL
);

-- Таблица: Categories
CREATE TABLE IF NOT EXISTS Categories (
    CategoryID INTEGER PRIMARY KEY AUTOINCREMENT,
    Name TEXT NOT NULL
);

-- Таблица: Tags
CREATE TABLE IF NOT EXISTS Tags (
    TagID INTEGER PRIMARY KEY AUTOINCREMENT,
    Name TEXT NOT NULL UNIQUE
);

-- Таблица: Cards
CREATE TABLE IF NOT EXISTS Cards (
    CardID INTEGER PRIMARY KEY AUTOINCREMENT,
    Question TEXT NOT NULL,
    Answer TEXT NOT NULL,
    UserID INTEGER DEFAULT(1),
    CategoryID INTEGER,
    UploadDate DATETIME DEFAULT(datetime('now')),
    Views INTEGER DEFAULT(0),
    Favorites INTEGER DEFAULT(0),
    FOREIGN KEY (UserID) REFERENCES Users(UserID) ON DELETE SET DEFAULT ON UPDATE CASCADE,
    FOREIGN KEY (CategoryID) REFERENCES Categories(CategoryID) ON DELETE SET NULL ON UPDATE CASCADE
);

-- Таблица: CardTags
CREATE TABLE IF NOT EXISTS CardTags (
    CardID INTEGER,
    TagID INTEGER,
    PRIMARY KEY (CardID, TagID),
    FOREIGN KEY (CardID) REFERENCES Cards(CardID) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (TagID) REFERENCES Tags(TagID) ON DELETE CASCADE ON UPDATE CASCADE
);

COMMIT TRANSACTION;
PRAGMA foreign_keys = on;
```

### Пояснения:

- **Таблица Users** без изменений, предоставляет информацию о пользователях.
- **Таблица Categories** добавлена для категорий, которые могут быть присвоены карточкам.
- **Таблица Tags** определяет теги, которые могут быть присвоены карточкам.
- **Таблица Cards** теперь включает `CategoryID` для связи с категориями и обновлена с полями, соответствующими вашим требованиям (например, `Favorites` вместо `adds`).
- **Таблица CardTags** создана для реализации отношения многие-ко-многим между карточками и тегами. Это позволяет одной карточке иметь множество тегов, а один тег быть связанным с множеством карточек.

### Ограничения на обновления и удаления:

- При удалении пользователя, карточки этого пользователя не удаляются, а `UserID` устанавливается в значение по умолчанию (если таковое предусмотрено).
- При удалении категории, `CategoryID` в карточках устанавливается в `NULL`, что позволяет карточкам оставаться без категории.
- Отношение между карточками и тегами реализовано таким образом, что при удалении карточки или тега соответствующие записи из `CardTags` также удаляются, что обеспечивает целостность данных.

Эти изменения и дополнения обеспечивают необходимую структуру данных для вашего приложения и позволяют гибко работать с карточками, категориями и тегами в рамках Django-приложения.

## Что такое Django ORM?


Django ORM (Object-Relational Mapping) — это мощный инструмент для работы с базой данных в Django, который позволяет разработчикам использовать объектно-ориентированный подход для работы с данными. ORM позволяет вам создавать, читать, обновлять и удалять данные в базе данных, используя высокоуровневые Python объекты вместо прямого написания SQL-запросов.

Django ORM поддерживает следующе БД:

- PostgreSQL
- MySQL
- SQLite
- Oracle
### Создание первой модели

Для создания моделей в Django 4.2, которые соответствуют вашим таблицам базы данных `Cards` и `Users`, выполните следующие шаги. Эти модели Django будут использоваться для взаимодействия с базой данных через ORM (Object-Relational Mapping, объектно-реляционное отображение) Django, позволяя работать с данными базы данных, используя Python объекты, вместо SQL запросов.

### Шаг 1: Создание Django проекта и приложения

Если у вас ещё нет Django проекта, начните с его создания. В терминале выполните следующие команды:

```bash
django-admin startproject myproject
cd myproject
django-admin startapp myapp
```

`myproject` — это имя вашего проекта, `myapp` — имя вашего Django приложения.

### Шаг 2: Определение моделей

В вашем Django приложении (`myapp`), откройте файл `models.py` и определите модели, соответствующие вашим таблицам базы данных.

```python
from django.db import models

class User(models.Model):
    UserID = models.AutoField(primary_key=True)
    FirstName = models.CharField(max_length=100, null=False)

class Card(models.Model):
    CardID = models.AutoField(primary_key=True)
    question = models.TextField(null=False)
    answer = models.TextField(null=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, default=1)
    upload_date = models.DateTimeField(auto_now_add=True)
    views = models.IntegerField(default=0)
    adds = models.IntegerField(default=0)
```

- `AutoField` используется для автоинкрементных полей.
- `CharField` и `TextField` используются для строковых полей, с ограничением по длине для `CharField`.
- `ForeignKey` используется для создания связи между моделями (в вашем случае между `Card` и `User`). `on_delete=models.CASCADE` указывает, что при удалении пользователя, все его карточки также будут удалены.
- `DateTimeField` с `auto_now_add=True` используется для автоматического сохранения даты создания записи.
- `IntegerField` используется для целочисленных полей.

В Django каждая модель, которая наследуется от `django.db.models.Model`, автоматически получает поле `id`, если только вы явно не определили другое поле с параметром `primary_key=True`. Это поле `id` является автоинкрементным (то есть значение автоматически увеличивается на 1 при создании новой записи) и уникальным для каждой записи в таблице. Этот механизм обеспечивает уникальный идентификатор для каждого объекта модели, что важно для отслеживания и ссылок на конкретные записи в базе данных.

### Когда определять `id` поле:

- Когда вы хотите использовать другой тип поля в качестве первичного ключа, например `UUIDField`.
- Когда вам нужны специфические настройки для первичного ключа, которые не предоставляются автоматически созданным полем `id`.

### Когда не нужно определять `id` поле:

- Если вам подходят параметры по умолчанию автоинкрементного целочисленного `id` поля, которое Django создает автоматически.
- Если нет специальных требований к первичному ключу в вашем приложении.

### Ссылки на `id` из других таблиц:

Если вы не определяли поле `id` вручную, Django всё равно создаст его для вас. В других таблицах или моделях, вы можете ссылаться на этот `id` при определении внешних ключей (`ForeignKey`), многие ко многим отношения (`ManyToManyField`) или один к одному отношения (`OneToOneField`). Например:

```python
class Profile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
```

В этом случае `user` будет ссылаться на автоматически созданный `id` поля пользователя.

## Подробнее про первичные ключи и ID

Когда вы создаете модель в Django, не обязательно явно указывать поле для первичного ключа (`primary_key`). Если вы не определите первичный ключ явно, Django автоматически добавит поле `id` в вашу модель, которое будет служить автоинкрементным (самоувеличивающимся) первичным ключом типа `AutoField`. Это означает, что для каждой новой записи в таблице будет генерироваться уникальный идентификатор.

### Первичный ключ и его формирование

- **Первичный ключ** (`primary_key`) — это уникальный идентификатор для каждой строки в таблице базы данных. Он используется для обеспечения уникальности данных и как ссылка для связей между таблицами.
- По умолчанию, Django создает поле `id` как `AutoField`, который автоматически увеличивается для каждой новой записи, обеспечивая уникальный идентификатор для каждого объекта.

### Индексация

- Поле, определенное как `primary_key`, автоматически становится индексированным. Это означает, что поиск, обновление и удаление записей по первичному ключу выполняются очень быстро.

### Явное определение первичного ключа

- Вы можете явно определить первичный ключ в модели, используя параметр `primary_key=True` для любого поля. Это полезно, если вы хотите использовать другой тип поля или другое имя поля в качестве первичного ключа.
- Как только вы явно определите первичный ключ, Django не будет добавлять поле `id` автоматически.

### Пример с явным первичным ключом

В вашем примере кода вы определяете `UserID` и `CardID` как автоинкрементные первичные ключи с помощью `models.AutoField(primary_key=True)`. Это абсолютно допустимо и работает аналогично автоматически сгенерированному полю `id`, но с вашими собственными именами полей.

```python
class User(models.Model):
    UserID = models.AutoField(primary_key=True)
    FirstName = models.CharField(max_length=100, null=False)

class Card(models.Model):
    CardID = models.AutoField(primary_key=True)
    question = models.TextField(null=False)
    answer = models.TextField(null=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, default=1)
    upload_date = models.DateTimeField(auto_now_add=True)
    views = models.IntegerField(default=0)
    adds = models.IntegerField(default=0)
```

### Что произойдет:

- **Уникальность**: `UserID` и `CardID` будут уникальными и автоинкрементными, обеспечивая уникальный идентификатор для каждой записи в соответствующих таблицах.
- **Связи**: Поле `user` в модели `Card` использует `ForeignKey` для создания связи "многие к одному" с моделью `User`, что означает, что множество карт могут быть ассоциированы с одним пользователем.
- **Индексация**: `UserID` и `CardID` будут индексированы, так как они определены как первичные ключи.

Использование собственных имен для полей первичного ключа может быть полезно для определенных ситуаций, особенно когда требуется более тонкая настройка или когда модели должны соответствовать уже существующей схеме базы данных. Однако, в большинстве случаев использование автоматически добавляемого поля `id` является достаточным и рекомендуемым подходом.
#### Различия `CharField` и `TextField`

`CharField` и `TextField` являются двумя типами полей для хранения текстовых данных в Django, каждое из которых имеет свои особенности и подходит для различных случаев использования. Вот основные различия между ними:

Ниже представлена таблица с описанием наиболее часто используемых типов полей моделей в Django 4.2, отсортированных по убыванию частоты использования (на мой взгляд), с указанием соответствующего типа данных в SQL и описанием их обычного применения:

#таблица

| Django Field Type           | SQL Data Type                        | Обычное Применение                                                                |
| --------------------------- | ------------------------------------ | --------------------------------------------------------------------------------- |
| `CharField`                 | VARCHAR                              | Короткие или средние строки, такие как имена, заголовки.                          |
| `TextField`                 | TEXT                                 | Длинные текстовые поля для статей, комментариев.                                  |
| `IntegerField`              | INTEGER                              | Целые числа без дробной части.                                                    |
| `BooleanField`              | BOOLEAN                              | Истина/ложь, да/нет, вкл/выкл переключатели.                                      |
| `DateTimeField`             | DATETIME                             | Дата и время для записей временных меток и сроков.                                |
| `ForeignKey`                | INTEGER REFERENCES (внешний ключ)    | Связь "один ко многим" между моделями.                                            |
| `FileField`                 | VARCHAR                              | Путь к файлу в файловой системе.                                                  |
| `ImageField`                | VARCHAR                              | Путь к изображению в файловой системе, с проверкой изображения.                   |
| `FloatField`                | REAL                                 | Числа с плавающей точкой для представления десятичных значений.                   |
| `DecimalField`              | NUMERIC                              | Десятичные числа с фиксированной точностью для финансовых данных.                 |
| `EmailField`                | VARCHAR                              | Адреса электронной почты.                                                         |
| `URLField`                  | VARCHAR                              | URL-адреса.                                                                       |
| `SlugField`                 | VARCHAR                              | Часть URL, которая может содержать только буквы, цифры, подчеркивания или дефисы. |
| `UUIDField`                 | UUID                                 | Универсально уникальные идентификаторы.                                           |
| `PositiveIntegerField`      | INTEGER                              | Целые положительные числа.                                                        |
| `PositiveSmallIntegerField` | SMALLINT                             | Маленькие целые положительные числа.                                              |
| `SmallIntegerField`         | SMALLINT                             | Маленькие целые числа.                                                            |
| `BigIntegerField`           | BIGINT                               | Очень большие целые числа.                                                        |
| `JSONField`                 | JSON                                 | Хранение и обработка структурированных данных в формате JSON.                     |
| `ManyToManyField`           | Связующая таблица с внешними ключами | Связь "многие ко многим" между моделями.                                          |
| `GenericIPAddressField`     | VARCHAR                              | IPv4 или IPv6 адреса.                                                             |
| `DurationField`             | BIGINT или INTERVAL                  | Промежутки времени.                                                               |

Обратите внимание, что точное соответствие типов данных в SQL может варьироваться в зависимости от используемой системы управления базами данных (например, PostgreSQL, MySQL, SQLite и т.д.). Django ORM заботится о преобразовании этих типов полей в подходящие типы данных SQL для целевой базы данных.

### CharField

- **Ограничение по длине:** `CharField` требует, чтобы вы явно указали максимальную длину текста, который может быть сохранен в поле, используя аргумент `max_length`. Это делает его идеальным для хранения строк с известной максимальной длиной, например, имен, заголовков, идентификаторов и других коротких текстовых данных.
- **Использование:** Из-за ограничения по длине `CharField` часто используется для полей, которые требуют ввода фиксированного или ограниченного количества символов, таких как пользовательские имена, пароли, адреса электронной почты и номера телефонов.

Пример использования `CharField`:
```python
from django.db import models

class MyModel(models.Model):
    name = models.CharField(max_length=100)  # Максимальная длина 100 символов
```

### TextField

- **Без ограничения по длине:** В отличие от `CharField`, `TextField` не требует указания максимальной длины, что делает его подходящим для хранения больших объемов текста, таких как статьи, блог-посты, комментарии, описания продуктов и другие длинные текстовые данные.
- **Использование:** `TextField` идеально подходит для текстов, размер которых может сильно варьироваться или которые могут превышать типичные ограничения длины, установленные для `CharField`.

Пример использования `TextField`:
```python
from django.db import models

class MyModel(models.Model):
    description = models.TextField()  # Поле для хранения больших текстовых данных
```

### Когда использовать каждое из них

- Используйте `CharField`, когда заранее известна максимальная длина текста и она не очень велика.
- Используйте `TextField`, когда текст может быть произвольной длины или когда он может быть достаточно длинным, чтобы превысить разумные ограничения `CharField`.

Выбор между `CharField` и `TextField` зависит от конкретных требований к данным в вашем приложении Django.


### Расширенная таблица параметров полей в Django 4.2 с пояснениями их использования
#таблица 

| Название параметра | Написание параметра               | Применение (типы полей)                                                                                   | Пояснения                                                                                                                                                   |
| ------------------ | --------------------------------- | --------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Null               | `null=True/False`                 | Все поля, кроме `ManyToManyField`, `TextField` (для баз данных, отличных от PostgreSQL)                   | Определяет, может ли поле содержать `NULL` в базе данных. Используется, когда поле может быть не указано или его значение неизвестно.                       |
| Blank              | `blank=True/False`                | Все поля                                                                                                  | Указывает, может ли поле быть пустым на уровне формы. Если `True`, поле не обязательно должно быть заполнено.                                               |
| Choices            | `choices=[...]`                   | Ограниченный список полей                                                                                 | Определяет набор допустимых значений для поля, часто используется для создания выпадающего списка в формах.                                                 |
| Default            | `default=...`                     | Все поля                                                                                                  | Значение по умолчанию для поля, используется, когда значение не предоставлено.                                                                              |
| Verbose Name       | `verbose_name=...`                | Все поля                                                                                                  | Читаемое человеком имя поля, используется в административном интерфейсе Django и при выводе форм.                                                           |
| Primary Key        | `primary_key=True/False`          | Все поля                                                                                                  | Указывает, что поле является первичным ключом модели. Каждая модель должна иметь ровно один первичный ключ.                                                 |
| Max Length         | `max_length=...`                  | `CharField`, `FileField`, `ImageField`, `SlugField`, `TextField` (для баз данных, отличных от PostgreSQL) | Максимальная длина значения поля в символах, часто используется для валидации ввода.                                                                        |
| Unique             | `unique=True/False`               | Все поля, кроме `ManyToManyField`, `FileField`, `ImageField`                                              | Указывает, что значение поля должно быть уникальным по всей таблице.                                                                                        |
| DB Index           | `db_index=True/False`             | Все поля, кроме `ManyToManyField`                                                                         | Создает индекс в базе данных для поля, что может ускорять операции поиска за счет дополнительного места на диске.                                           |
| Help Text          | `help_text=...`                   | Все поля                                                                                                  | Текст помощи, который объясняет назначение поля, отображается в интерфейсе администратора.                                                                  |
| Editable           | `editable=True/False`             | Все поля                                                                                                  | Если `False`, поле не будет отображаться в административном интерфейсе и формах для редактирования.                                                         |
| Auto Now           | `auto_now=True/False`             | `DateTimeField`, `DateField`, `TimeField`                                                                 | Поле будет автоматически установлено в текущую дату при каждом сохранении объекта.                                                                          |
| Auto Now Add       | `auto_now_add=True/False`         | `DateTimeField`, `DateField`, `TimeField`                                                                 | Поле будет автоматически установлено в текущую дату при первом создании объекта.                                                                            |
| Unique For Date    | `unique_for_date=...`             | `DateField`, `DateTimeField`                                                                              | Уникальность значения поля будет проверяться в сочетании с датой в другом поле.                                                                             |
| Unique For Month   | `unique_for_month=...`            | `DateField`, `DateTimeField`                                                                              | Аналогично `unique_for_date`, но проверяется уникальность в рамках месяца.                                                                                  |
| Unique For Year    | `unique_for_year=...`             | `DateField`, `DateTimeField`                                                                              | Аналогично `unique_for_date`, но проверяется уникальность в рамках года                                                                                     |
| Upload To          | `upload_to=...`                   | `FileField`, `ImageField`                                                                                 | Определяет путь или функцию, которая генерирует путь для сохранения загружаемого файла. Используется для организации файлов на сервере.                     |
| URL Validator      | `validators=[...]`                | `URLField`, `EmailField`, `SlugField`, `CharField`, `TextField`                                           | Список валидаторов для проверки данных перед сохранением объекта. Может включать стандартные валидаторы Django или пользовательские функции.                |
| Error Messages     | `error_messages={'invalid': ...}` | Все поля                                                                                                  | Словарь с переопределениями стандартных сообщений об ошибках. Используется для кастомизации отображения ошибок валидации.                                   |
| On Delete          | `on_delete=models.CASCADE`        | `ForeignKey`, `OneToOneField`                                                                             | Определяет поведение при удалении связанного объекта. `models.CASCADE` означает, что при удалении объекта, все связанные с ним объекты также будут удалены. |
| Related Name       | `related_name=...`                | `ForeignKey`, `ManyToManyField`, `OneToOneField`                                                          | Имя для обратной связи от связанного объекта к объекту, определяющему внешний ключ. Используется для запросов из связанной модели.                          |
| Related Query Name | `related_query_name=...`          | `ForeignKey`, `ManyToManyField`, `OneToOneField`                                                          | Имя для обратного запроса в QuerySet связанной модели.                                                                                                      |
| To Field           | `to_field=...`                    | `ForeignKey`, `OneToOneField`                                                                             | Указывает поле связанной модели, которое будет использоваться в качестве внешнего ключа.                                                                    |
| DB Column          | `db_column=...`                   | Все поля                                                                                                  | Имя столбца в базе данных для данного поля. Если не указано, Django использует имя поля.                                                                    |
| DB Table           | `db_table=...`                    | Метакласс модели                                                                                          | Имя таблицы в базе данных для модели. Если не указано, Django генерирует имя на основе имени приложения и модели.                                           |
| DB Tablespace      | `db_tablespace=...`               | Все поля, которые поддерживают индексы                                                                    | Имя табличного пространства, используемого для индексов (если поддерживается базой данных).                                                                 |
| Auto Created       | `auto_created=True/False`         | Внутреннее использование в Django                                                                         | Указывает, что поле было создано автоматически Django (например, как часть связи `ManyToManyField`).                                                        |
| Serialize          | `serialize=True/False`            | Внутреннее использование в Django                                                                         | Указывает, должно ли поле быть сериализовано Django сериализаторами.                                                                                        |
| Validators         | `validators=[...]`                | Все поля                                                                                                  | Список функций для проверки значения поля. Каждая функция должна принимать одно значение и бросать `ValidationError`, если значение недопустимо.            |
| Error Messages     | `error_messages={...}`            | Все поля                                                                                                  | Позволяет переопределить стандартные сообщения об ошибках для поля.                                                                                         |

Эти параметры поля помогают настроить поведение полей модели в Django, включая валидацию, отображение в формах и административном интерфейсе, а также отношения между различными моделями в базе данных.
### Шаг 3: Регистрация моделей в админке

Чтобы работать с этими моделями через админ-панель Django, зарегистрируйте их в файле `admin.py` вашего приложения.

```python
from django.contrib import admin
from .models import User, Card

admin.site.register(User)
admin.site.register(Card)
```

### Шаг 4: Миграции

Миграции используются Django для применения изменений вашей модели в базе данных. После определения моделей, выполните следующие команды для создания и применения миграций:

```bash
python manage.py makemigrations
python manage.py migrate
```

`makemigrations` создаст новые миграции на основе изменений ваших моделей, а `migrate` применит эти миграции к базе данных.


### Шаг 5: Работа с моделями

Теперь вы можете использовать модели для создания, чтения, обновления и удаления записей в базе данных через Django shell или ваше приложение. Например, для добавления нового пользователя и карточки через Django shell, выполните:

```bash
python manage.py shell
```

Затем в shell:

```python
from myapp.models import User, Card
user = User(FirstName="Иван")
user.save()
card = Card(question="Вопрос", answer="Ответ", user=user)
card.save()
```

Эти команды добавят новую запись в каждую таблицу, используя Django ORM.

### Заключение

Теперь вы знаете, как создать базовый проект Django, определить модели для работы с базой данных, применить миграции для создания таблиц в базе данных и работать с этими моделями для управления данными. Django ORM значительно упрощает работу с базой данных, позволяя фокусироваться на логике приложения, а не на SQL запросах.


Давайте разберемся с моделями в Django, исходя из ваших вопросов, без использования кода и сложных терминов.

## Что такое модель в Django?

Модель в Django — это специальный класс, который описывает структуру вашей информации (данных) для хранения в базе данных. Каждая модель соответствует таблице в базе данных: атрибуты класса (поля модели) становятся столбцами таблицы, а каждый экземпляр (объект) модели — строкой в этой таблице.

### Метаклассы

С точки зрения технических деталей, в основе механизма моделей Django действительно лежат метаклассы, но для понимания и использования моделей в повседневной разработке эту деталь можно опустить. Главное знать, что Django использует эти метаклассы для "магии" вроде автоматического создания таблиц в базе данных на основе ваших моделей.

### Связи между моделями

Связи между моделями позволяют описывать взаимосвязи между данными. Django предлагает три типа связей: "один к одному", "один ко многим" и "многие ко многим". 

- **"Один к одному"** используется, когда один объект модели строго соответствует одному объекту другой модели. Например, у пользователя может быть только один паспорт.
- **"Один ко многим"** наиболее часто встречается, когда один объект (скажем, статья в блоге) может быть связан с множеством других объектов (комментарии к статье). В Django это реализуется через внешние ключи.
- **"Многие ко многим"** используется, когда объекты одной модели могут быть связаны с множеством объектов другой модели, и наоборот. Примером может служить ситуация, когда несколько авторов пишут несколько книг.

### Обращение через точку

Когда вы устанавливаете связь между моделями и хотите получить доступ к связанным данным, вы можете делать это через точку. Например, если у вас есть объект статьи и вы хотите получить все комментарии к этой статье, вы можете сделать это примерно так: `article.comments.all()`. Это работает благодаря тому, что Django создает "обратные" связи между моделями, позволяя обращаться к связанным данным напрямую и интуитивно понятно.

### Как это работает в целом

1. **Определение моделей**: Вы описываете структуру ваших данных в классах Python, используя специальные поля для определения типов данных (текст, число, дата и т.д.).
2. **Создание таблиц**: После определения моделей Django может автоматически создать соответствующие таблицы в базе данных.
3. **Работа с данными**: Вы используете объекты ваших моделей для создания, чтения, обновления и удаления данных. Django предлагает богатый набор инструментов для эффективной работы с данными, включая фильтрацию, сортировку и агрегацию.

Важно понимать, что модели — это мощный и гибкий инструмент Django для работы с базой данных, который скрывает многие сложности SQL, позволяя разработчикам сосредоточиться на логике приложения.

## Таблица основных инструментов выборки

Создание сводной таблицы методов для работы с данными в Django ORM, от наиболее часто используемых к менее распространенным, поможет разработчикам понять разнообразие инструментов для управления базой данных. Вот она:

#таблица

| Название            | Пример синтаксиса                     | Словесные пояснения                                                                                                                                                     |
|---------------------|---------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `get`               | `Model.objects.get(pk=1)`             | Используется для получения одного объекта по уникальному идентификатору или другим критериям. Вызывает исключение, если объект не найден или найдено более одного объекта. |
| `filter`            | `Model.objects.filter(name="John")`   | Возвращает QuerySet, содержащий объекты, соответствующие заданным критериям. Используется для получения набора объектов с возможностью дальнейшей фильтрации.            |
| `create`            | `Model.objects.create(name="John")`   | Создаёт и сохраняет новый объект в одной операции. Используется для удобного добавления новых записей в базу данных.                                                      |
| `get_or_create`     | `Model.objects.get_or_create(name="John")` | Пытается получить объект по заданным критериям. Если объект не найден, создаёт новый с этими параметрами. Возвращает кортеж (объект, создан ли объект).                 |
| `update_or_create`  | `Model.objects.update_or_create(name="John")` | Обновляет объект, если он найден по заданным критериям, или создаёт новый, если объект не найден. Возвращает кортеж (объект, создан ли объект).                        |
| `all`               | `Model.objects.all()`                 | Возвращает QuerySet, содержащий все объекты модели. Используется для получения всех записей таблицы.                                                                     |
| `delete`            | `instance.delete()`                   | Удаляет объект из базы данных. Может быть вызван как для отдельного объекта, так и для QuerySet.                                                                          |
| `update`            | `Model.objects.filter(name="John").update(name="Mike")` | Обновляет поля объектов, соответствующих заданным критериям, без необходимости их индивидуального сохранения. Используется для массового обновления записей.            |
| `exclude`           | `Model.objects.exclude(name="John")`  | Возвращает QuerySet, исключая объекты, соответствующие заданным критериям. Используется для исключения определённых записей из выборки.                                   |
| `annotate`          | `Model.objects.annotate(new_field=Count('other_model'))` | Добавляет временное поле к каждому объекту в QuerySet, которое представляет собой агрегированное значение, например, количество связанных объектов.                      |
| `aggregate`         | `Model.objects.aggregate(Count('field_name'))` | Выполняет агрегацию данных по всему QuerySet, возвращая словарь с агрегированными значениями. Используется для подсчёта, суммирования, нахождения средних значений и т. д. |
| `values` и `values_list` | `Model.objects.values('name')`    | Возвращает QuerySet, содержащий словари (или список значений, если используется `values_list`), со значениями указанных полей. Используется для получения конкретных полей объектов. |

Эти методы представляют основу для управления данными в приложениях Django, позволяя разработчикам эффективно взаимодействовать с базой данных через высокоуровневый Python API, минимизируя прямую работу с SQL-запросами. Использование этих методов делает код более читаемым, упрощает поддержку и обновление приложений.

- **Метод `get`** идеально подходит для ситуаций, когда вы точно знаете, что в базе данных существует только одна запись, соответствующая вашим критериям. Он часто используется для получения объектов по первичному ключу.

- **Метод `filter`** особенно полезен, когда вам нужно работать с набором объектов, удовлетворяющих определённым условиям, например, для отображения списка элементов на веб-странице.

- **Методы `create`, `get_or_create` и `update_or_create`** упрощают добавление и обновление записей, автоматически обрабатывая рутинные задачи проверки существования объекта и его последующего создания или обновления.

- **Метод `all`** является отправной точкой для многих запросов, позволяя получить полный список объектов модели для дальнейшей обработки или отображения.

- **Операция `delete`** критически важна для управления жизненным циклом данных, позволяя удалять как отдельные объекты, так и целые группы объектов, удовлетворяющих определённым условиям.

- **Метод `update`** обеспечивает эффективное массовое обновление атрибутов объектов без необходимости итерировать по каждому объекту отдельно.

- **Методы `exclude`, `annotate` и `aggregate`** предоставляют расширенные возможности для фильтрации, аннотирования и агрегации данных, позволяя выполнять сложные запросы и анализ данных прямо в Django, без необходимости использования сложных SQL-запросов.

- **`values` и `values_list`** позволяют удобно извлекать определённые поля из набора объектов, что может быть полезно для создания словарей или списков значений для последующей обработки или передачи в контекст шаблона.

Важно отметить, что использование этих методов не только упрощает работу с базой данных, но и помогает поддерживать безопасность приложения, поскольку Django автоматически экранирует значения, предотвращая SQL-инъекции. Эти инструменты делают Django мощным и гибким фреймворком для разработки веб-приложений любой сложности.
## О миграциях

Давайте разберемся, как Django использует миграции для создания и обновления таблиц в базе данных, что происходит за кулисами при выполнении миграций, и почему вы можете видеть много различных моделей, когда выполняете их.

Давайте разберемся, как работает механизм миграций в Django, используя простые объяснения. Миграции в Django — это способ Django отслеживать изменения в вашей модели данных, чтобы он мог автоматически обновлять схему базы данных без потери данных.

### Что такое миграции?

Миграции в Django - это способ Django отслеживать изменения в ваших моделях (т.е., описаниях таблиц в вашем коде) и отражать эти изменения в базе данных. Это включает в себя создание новых таблиц, изменение существующих таблиц (например, добавление новых полей) и удаление таблиц.

### Создание файла миграции с `makemigrations`

Команда:
```bash
python manage.py makemigrations
```
Эта команда "говорит" Django: "Посмотри на изменения, которые я сделал в моделях, и создай для меня файл миграции, который описывает, как эти изменения применить к базе данных". Файл миграции — это просто Python файл, который Django знает, как выполнить, чтобы изменить схему вашей базы данных (например, добавить таблицу, изменить поле и т.д.).

### Применение миграций с `migrate`

Команда:
```bash
python manage.py migrate
```
Эта команда "говорит" Django: "Примени файлы миграции, которые ты создал, к базе данных". Это изменит структуру базы данных так, чтобы она соответствовала вашим моделям. Если вы только начинаете проект, Django также создаст необходимые таблицы для своих внутренних моделей.

### Просмотр SQL кода миграции с `sqlmigrate`

Команда:
```bash
python manage.py sqlmigrate cards 0001
```
Это позволяет вам увидеть, какой именно SQL код будет выполнен при применении конкретной миграции. В примере `cards` — это название вашего приложения, а `0001` — номер миграции. Это полезно для понимания того, что Django собирается сделать с вашей базой данных, не применяя миграцию.

### Просмотр статуса миграций с `showmigrations`

Команда:
```bash
python manage.py showmigrations
```
Это покажет вам список всех миграций для каждого из ваших приложений и отметит те, которые были применены. Это хороший способ быстро проверить, какие миграции были выполнены, а какие еще предстоит применить.

### Откат всех миграций с `migrate ... zero`

Команда:
```bash
python manage.py migrate cards zero
```
Эта команда "говорит" Django: "Откати все миграции для приложения `cards`". Это полезно, если вы хотите "почистить" вашу базу данных от всех изменений, примененных через миграции для определенного приложения. Однако будьте осторожны, так как это может привести к потере данных.

### Откат миграции до определенной версии с `migrate ... 0001`

Команда:
```bash
python manage.py migrate cards 0001
```
Это позволяет вам откатить миграции приложения `cards` до состояния после применения миграции `0001`. Это может быть полезно, если последующие миграции вызвали проблемы и вы хотите вернуться к известному хорошему состоянию. Также может использоваться для "отката" миграций до начальной точки, если номер миграции указать как `zero`.

Миграции в Django — мощный инструмент для управления вашей базой данных, позволяющий изменять структуру данных без потерь и с минимальными усилиями.

### Почему таблицы не появляются в базе данных?

После определения моделей в коде, Django не создает или изменяет таблицы в базе данных автоматически. Вам нужно явно указать Django сделать это с помощью миграций.

### Нужные терминальные команды

1. **Создание миграций:** Чтобы создать миграции на основе ваших моделей, используйте команду:

   ```
   python manage.py makemigrations
   ```

   Эта команда генерирует новые миграционные файлы, которые содержат инструкции для изменения базы данных.

2. **Просмотр SQL команд миграции:** Если вы хотите увидеть, какие SQL команды будут выполнены при применении миграции, используйте команду:

   ```
   python manage.py sqlmigrate appname migrationname
   ```

   Замените `appname` на имя вашего приложения и `migrationname` на имя файла миграции (например, `0001_initial`).

3. **Выполнение миграций:** Чтобы применить миграции к вашей базе данных, используйте команду:

   ```
   python manage.py migrate
   ```

   Это изменит структуру базы данных в соответствии с миграционными файлами.

### Почему миграций так много?

При первом выполнении миграций, вы можете увидеть большое количество миграций, не связанных напрямую с вашими моделями. Это происходит потому, что Django также создает ряд системных таблиц, необходимых для его работы, например, для аутентификации пользователей и управления правами доступа.

Также, миграции могут быть созданы для изменения схемы базы данных, добавления новых таблиц или полей, изменения типов данных и других операций, связанных с управлением структурой данных в вашем приложении.

Кроме того, миграции позволяют вам сохранять историю изменений в базе данных и легко откатывать или применять эти изменения при необходимости. Это очень полезно при разработке и поддержке проекта.

Наконец, миграции могут быть созданы также для обновления данных в базе данных. Например, вы можете создать миграцию для добавления начальных данных или обновления существующих записей.

В целом, количество миграций зависит от сложности вашего проекта и количества изменений, которые вы вносите в базу данных.
### Как Django создает таблицы?

Когда вы выполняете миграции, Django преобразует описания моделей в вашем коде в SQL команды, которые затем выполняются в базе данных для создания или изменения таблиц. Имя файла миграции обычно состоит из номера и описания изменений (например, `0001_initial`), где первая часть (`0001`) указывает на порядковый номер миграции, а вторая часть (`initial`) - краткое описание содержания миграции.Django использует ORM (Object-Relational Mapping), чтобы создавать таблицы в базе данных. ORM позволяет разработчикам работать с базой данных, используя объектно-ориентированный подход, вместо прямой работы с SQL.

Когда вы определяете модель в Django, вы создаете класс, который наследуется от `django.db.models.Model`. Класс модели содержит поля, которые определяют структуру таблицы в базе данных. Django автоматически преобразует эти поля в соответствующие столбцы таблицы.

После определения модели вы можете создать миграцию. Миграция - это файл Python, который содержит инструкции для создания или изменения таблицы. Выполнение миграции приводит к выполнению соответствующих SQL команд в базе данных.

Процесс создания таблицы с помощью миграций состоит из нескольких шагов:

1. Определение модели: Вы определяете класс модели, указывая поля и их типы данных.
2. Создание миграции: Вы запускаете команду `python manage.py makemigrations`, которая анализирует вашу модель и генерирует файл миграции.
3. Применение миграции: Вы запускаете команду `python manage.py migrate`, которая выполняет SQL команды из файла миграции для создания или изменения таблицы в базе данных.

Django также предоставляет возможность автоматического обновления таблицы при изменении модели. Если вы вносите изменения в модель, Django может сгенерировать миграцию, которая применит эти изменения к таблице без потери данных.

В целом, Django обеспечивает удобный и автоматизированный способ создания и обновления таблиц в базе данных с помощью миграций.

Миграции в Django — это система контроля версий для ваших моделей и базы данных. Они позволяют Django применять изменения в моделях (например, добавление нового поля, удаление модели и т.д.) к базе данных, не теряя данных. Миграции создаются автоматически и применяются к базе данных для синхронизации схемы данных с вашими моделями.

Вот что произойдет, когда вы создадите и примените миграции для ваших моделей `User` и `Card`:

### Создание файла миграции

1. Вы запустите команду для создания миграций:
   ```
   python manage.py makemigrations
   ```
   
   Django анализирует ваши модели и определяет, что были созданы две новые модели: `User` и `Card`.

2. На основе этого анализа Django сгенерирует новый файл миграции в папке `migrations` вашего приложения. Этот файл будет содержать классы Python, описывающие необходимые операции для создания соответствующих таблиц в базе данных.

   Файл миграции будет выглядеть примерно так:

   ```python
   # Generated by Django 4.2 on YYYY-MM-DD HH:MM
   
   from django.db import migrations, models
   import django.db.models.deletion
   
   class Migration(migrations.Migration):
   
       initial = True
   
       dependencies = [
       ]
   
       operations = [
           migrations.CreateModel(
               name='User',
               fields=[
                   ('UserID', models.AutoField(primary_key=True, serialize=False)),
                   ('FirstName', models.CharField(max_length=100)),
               ],
           ),
           migrations.CreateModel(
               name='Card',
               fields=[
                   ('CardID', models.AutoField(primary_key=True, serialize=False)),
                   ('question', models.TextField()),
                   ('answer', models.TextField()),
                   ('upload_date', models.DateTimeField(auto_now_add=True)),
                   ('views', models.IntegerField(default=0)),
                   ('adds', models.IntegerField(default=0)),
                   ('user', models.ForeignKey(default=1, on_delete=django.db.models.deletion.CASCADE, to='appname.user')),
               ],
           ),
       ]
   ```

   В этом файле `initial = True` говорит о том, что это начальная миграция для приложения, и `dependencies` перечисляет зависимости от других миграций.

### Применение миграций

1. Затем вы запустите команду для применения миграций к базе данных:
   ```
   python manage.py migrate
   ```

   Django применит миграции в порядке их зависимостей. Он преобразует операции, описанные в файлах миграции, в SQL-команды, специфичные для вашей базы данных.

2. Во время применения миграций Django выполнит следующее:
   - Создаст таблицу `user` с полями `UserID` (который будет автоинкрементным первичным ключом) и `FirstName`.
   - Создаст таблицу `card` с полями `CardID`, `question`, `answer`, `upload_date`, `views`, `adds` и внешним ключом `user`, который ссылается на таблицу `user`.

3. После применения миграций, состояние вашей базы данных будет соответствовать состоянию ваших моделей.

Миграции очень важны, так как они позволяют изменять структуру базы данных без потери данных и без необходимости вручную редактировать SQL-команды. Они также обеспечивают возможность отката изменений, если что-то пойдет не так.

### Кастномные имена миграциям

При создании файла миграции можно задавать ему имя и откатываться на предыдущую версию:

`python manage.py makemigrations cards --имя файла миграции`

`python manage.py migrate cards название файла миграции- откат на предыдущую версию`

#### **Как это работает?**

Когда вы выполняете команду `makemigrations`, Django анализирует модели в вашем проекте и создает файлы миграции для каждого изменения в моделях. По умолчанию, Django генерирует имя файла миграции, основываясь на имени приложения и названии модели.

Однако, вы можете задать кастомное имя файла миграции, указав его после имени приложения при выполнении команды `makemigrations`. Например:

`python manage.py makemigrations cards --имя файла миграции`

В этом случае, Django создаст файл миграции с указанным именем в папке `migrations` вашего приложения.

Когда вы хотите откатиться на предыдущую версию миграции, вы можете использовать команду `migrate` с указанием названия файла миграции. Например:

`python manage.py migrate cards название файла миграции- откат на предыдущую версию`

Django найдет указанный файл миграции и выполнит откат до предыдущей версии базы данных.

### Заключение

Миграции в Django - мощный инструмент для управления структурой базы данных. Они позволяют вам изменять структуру базы данных без прямого написания SQL кода, обеспечивая согласованность между вашими моделями и базой данных. Понимание процесса миграции и соответствующих команд поможет вам эффективно управлять вашими моделями и базой данных в проектах на Django.

## Инструменты запросов

Django ORM (Object-Relational Mapping) предоставляет мощный и интуитивно понятный способ взаимодействия с базой данных, используя Python-код. Рассмотрим основные методы для выполнения CRUD (Create, Read, Update, Delete) операций в Django ORM.

### Создание объектов (Create)

- **Создание и сохранение объекта отдельно**: Вы можете создать экземпляр модели, установив её атрибуты, а затем вызвать метод `.save()` для сохранения объекта в базе данных.
  
- **Метод `create`**: Этот метод позволяет создать и сохранить объект в одной операции. Он принимает аргументы, которые соответствуют полям модели, и возвращает созданный объект.

- **Метод `get_or_create`**: Возвращает объект, основываясь на переданных аргументах. Если объект не найден, он будет создан с этими аргументами. Возвращает кортеж `(object, created)`, где `object` — это объект модели, а `created` — булево значение, указывающее, был ли объект создан.

- **Метод `update_or_create`**: Похож на `get_or_create`, но обновляет объект, если он уже существует, иначе создаёт новый. Также возвращает кортеж `(object, created)`.

### Чтение объектов (Read)

- **Метод `get`**: Используется для получения одного объекта, который соответствует заданным критериям. Если объект не найден, возникает исключение `DoesNotExist`. Если найдено более одного объекта, возникает исключение `MultipleObjectsReturned`.

- **Метод `all`**: Возвращает QuerySet, содержащий все объекты модели.

- **Метод `filter`**: Возвращает QuerySet, содержащий объекты, которые соответствуют заданным критериям фильтрации.

- **Методы `exclude`**: Возвращает QuerySet, исключая объекты, которые соответствуют заданным критериям.

- **Методы `annotate`**: Позволяет добавлять аннотации к объектам в QuerySet, например, для выполнения агрегации данных.

### Обновление объектов (Update)

- **Изменение и сохранение объекта**: Получив объект, вы можете изменить его атрибуты и вызвать метод `.save()`, чтобы обновить объект в базе данных.

- **Метод `update` в QuerySet**: Позволяет обновить все объекты в QuerySet, установив указанные значения атрибутов.

### Удаление объектов (Delete)

- **Метод `delete`**: Может быть вызван как для отдельного объекта, так и для QuerySet. Удаляет объект(ы) из базы данных.

### Работа с отношениями

- **Для связи "многие ко многим" (`ManyToManyField`)**: Используйте методы `.add()`, `.create()`, `.remove()`, `.clear()` на поле связи для управления связями между объектами.

- **Для связи "один к одному" и "один ко многим"**: Прямое присваивание объектов или их id для установления или изменения связей между объектами.

Эти методы позволяют легко и интуитивно управлять данными в ваших Django-приложениях, обеспечивая высокий уровень абстракции от SQL и базы данных. ### Дополнительные возможности Django ORM для управления данными

Django ORM не только облегчает выполнение базовых CRUD операций, но и предоставляет расширенные инструменты для более сложных запросов и манипуляций с данными, что делает работу с базой данных более мощной и гибкой.

### Агрегация данных

Django ORM позволяет выполнять агрегацию данных, то есть проводить операции, такие как подсчёт, суммирование, нахождение среднего, максимума и минимума по заданным наборам данных. Это делается с помощью метода `aggregate()`, который возвращает значения агрегированных вычислений.

### Группировка данных

С помощью метода `annotate()` можно добавлять аннотации к объектам в QuerySet. Это часто используется для группировки данных с последующей агрегацией, например, для подсчёта количества связанных объектов в каждой группе.

### Транзакции

Django позволяет управлять транзакциями базы данных, что критически важно для поддержания целостности данных при выполнении операций, которые не должны быть прерваны или должны быть выполнены полностью. Это может быть реализовано через декораторы `@transaction.atomic` или с помощью контекстного менеджера `with transaction.atomic()`.

### Наследование моделей

Django поддерживает наследование моделей, позволяя создавать базовые модели и расширять их в дочерних моделях. Это полезно для уменьшения дублирования кода и логического группирования общих атрибутов и поведения.

### Использование менеджеров моделей

Каждая модель Django имеет по крайней мере один менеджер объектов, доступный через атрибут `.objects`. Менеджеры предоставляют интерфейс базы данных для моделей и могут быть расширены для добавления пользовательских методов запросов.

### Оптимизация запросов

Django ORM предлагает инструменты для оптимизации запросов, такие как `select_related()` и `prefetch_related()`, которые помогают уменьшить количество запросов к базе данных за счёт предварительной загрузки связанных объектов.

### Валидация данных

Django предоставляет систему валидации для моделей и форм, позволяя проверять данные перед их сохранением в базе данных. Валидация может включать проверку типов данных, длины строк, уникальности и выполнения пользовательских функций валидации.

### Сигналы

Django позволяет моделям отправлять и получать сигналы в ответ на определённые действия, такие как создание, обновление или удаление объектов. Это может быть полезно для выполнения дополнительной логики до или после изменения объектов в базе данных.

Всё это делает Django мощным инструментом для работы с базами данных в веб-разработке, обеспечивая разработчиков всем необходимым для эффективного управления данными.


## Django `shell`

### Оболочка Django (Django Shell)

**Django Shell** — это мощный интерфейс командной строки, который позволяет взаимодействовать с вашим Django-проектом в интерактивном режиме. Это особенно полезно для тестирования моделей, выполнения операций с базой данных, прототипирования кода и исследования API Django без необходимости запускать веб-сервер или создавать веб-интерфейсы.

**Оболочка Django** предоставляет интерактивную среду для взаимодействия с вашим Django-проектом. Она позволяет выполнять команды и операции, а также получать результаты непосредственно в командной строке.

Когда вы запускаете оболочку Django, она загружает все необходимые настройки вашего проекта, включая модели, маршруты и другие компоненты. Затем вы можете выполнять различные операции, используя доступные функции и методы Django.

Например, вы можете создавать, изменять или удалять записи в базе данных с помощью моделей Django. Вы также можете выполнять сложные запросы к базе данных или проводить анализ данных с помощью ORM (Object-Relational Mapping) Django.

**Оболочка Django** также позволяет импортировать и использовать сторонние библиотеки и модули Python. Это полезно для прототипирования кода или тестирования различных функций без необходимости создавать отдельные файлы или скрипты.

Когда вы закончите работу в оболочке Django, вы можете просто выйти из неё или перезагрузить её для выполнения других операций. Оболочка сохраняет состояние вашего проекта между запусками, поэтому вы можете продолжить работу с того места, где остановились.

Оболочка Django является мощным инструментом для разработки и отладки вашего Django-проекта. Она позволяет вам быстро проверять и тестировать различные функции и операции, не запуская полноценный веб-сервер или создавая сложные интерфейсы.

#### Зачем и для чего?

- **Тестирование и прототипирование:** Быстро тестировать модели, функции и методы.
- **Работа с базой данных:** Выполнение CRUD-операций непосредственно с моделями.
- **Исследование:** Изучение и проверка структуры проекта и его компонентов.

#### Команда для запуска оболочки

```bash
python manage.py shell
```

### Импорт модели и создание записи

После запуска оболочки можно импортировать модели и работать с ними напрямую.

```python
# Импортируем модель User
from myapp.models import User, Card

# Создаем нового пользователя
user = User(FirstName="John Doe")
user.save()  # Сохраняем объект в базе данных
```

### Почему данные не появляются в базе автоматически?

Создание объекта модели в памяти не означает его автоматического сохранения в базе данных. Django использует "ленивую" стратегию записи в базу данных, что означает, что данные фактически записываются в базу только при вызове метода `save()` объекта модели.

### Как посмотреть поля объекта через shell?

После создания объекта вы можете исследовать его поля, используя имя атрибута:

```python
print(user.FirstName)  # Выведет "John Doe"
```

### Объекты и строки таблицы

В Django каждый объект модели представляет собой строку в таблице базы данных. Это означает, что при создании и сохранении объекта модели вы фактически добавляете новую строку в соответствующую таблицу.

### Использование `pk` в Django

`pk` (primary key, первичный ключ) — это универсальный способ обращения к идентификатору объекта в Django, не заботясь о том, как называется поле первичного ключа в вашей модели (`id`, `UserID` или как-то иначе). Это делает код более универсальным и упрощает обращение к объектам, особенно когда имя поля первичного ключа неизвестно или может измениться.

Пример использования `pk` для получения объекта:

```python
# Получение пользователя по первичному ключу
user = User.objects.get(pk=1)
```

### Выводы

- Django Shell предоставляет мощный интерфейс для работы с вашим проектом.
- Создание объекта модели не означает его автоматическое сохранение в базе данных. Используйте метод `save()` для этого.
- Поля объекта модели можно исследовать напрямую через атрибуты.
- `pk` предоставляет универсальный способ обращения к первичному ключу объекта, упрощая работу с моделями.

## `Connection` object

Django предоставляет мощный инструмент для отслеживания и анализа SQL-запросов, выполняемых через его ORM (Object-Relational Mapping — объектно-реляционное отображение). Это позволяет разработчикам понимать, какие запросы отправляются в базу данных, и оптимизировать их при необходимости. Давайте рассмотрим, как можно использовать этот инструмент в Django Shell. 

`Connection` object это объект, который представляет соединение с базой данных.
### Просмотр SQL-запросов через Django Shell

Для начала необходимо активировать режим отладки Django, чтобы иметь доступ к информации о SQL-запросах. Обычно это делается путем установки `DEBUG = True` в файле `settings.py` вашего проекта. Однако помните, что включение режима отладки в продуктивной среде не рекомендуется из-за соображений безопасности и производительности.

#### Запуск Django Shell

```bash
python manage.py shell
```

#### Импорт и использование connection

```python
from django.db import connection
```

`connection` — это объект, который предоставляет доступ к текущему соединению с базой данных. Он содержит множество полезных атрибутов и методов, включая `queries`, который представляет собой список выполненных SQL-запросов в текущей сессии.

#### Работа с `connection.queries`

```python
# Выполняем какие-то операции с моделями, например, создаем нового пользователя
user = User(FirstName="John Smith")
user.save()

# После сохранения пользователя в базу данных, проверяем SQL-запросы
print(connection.queries)
```

Этот код покажет список словарей, каждый из которых содержит информацию о выполненном SQL-запросе, включая сам запрос и время его выполнения. Это может быть полезно для оптимизации и отладки ваших запросов к базе данных.

#### Просмотр последнего запроса

Чтобы просмотреть информацию о последнем выполненном запросе, можно использовать индекс `-1`:

```python
# Просмотр последнего SQL-запроса
last_query = connection.queries[-1]
print(last_query)
```

Это покажет информацию о последнем запросе, включая его текст и время выполнения.

### Выводы

- Использование `connection.queries` в Django Shell позволяет разработчикам просматривать SQL-запросы, отправляемые в базу данных. Это может быть крайне полезно для отладки и оптимизации запросов.
- Важно помнить, что этот механизм следует использовать только в разработке или при отладке, поскольку включение режима отладки (`DEBUG = True`) в продуктивной среде может привести к снижению производительности и потенциальным проблемам с безопасностью.
- Просмотр последнего запроса может быть полезен для быстрой проверки того, как Django ORM преобразует операции с моделями в SQL-запросы, а также для оценки их эффективности и корректности.

## Shell `plus`

Чтобы сделать работу с Django Shell более продуктивной и удобной, можно использовать пакет `ipython` и расширения Django, такие как `django-extensions`. `IPython` предоставляет более мощный интерфейс для интерактивной работы с Python, включая улучшенное автодополнение, подсказки команд и многое другое. `django-extensions` добавляет набор дополнительных утилит и расширений для Django, в том числе `shell_plus`, которая автоматически импортирует все модели проекта при запуске оболочки, и `print_sql`, которая позволяет в реальном времени видеть SQL-запросы, генерируемые Django ORM.

**Зачем она нам нужна?**

- Улучшенное автодополнение и подсказки команд в Django Shell.
- Автоматический импорт всех моделей проекта при запуске оболочки.
- Возможность просмотра SQL-запросов, генерируемых Django ORM в реальном времени.
- Дополнительные утилиты и расширения для Django, которые могут быть полезными при разработке и отладке проекта.
- Удобный и продуктивный интерфейс для интерактивной работы с Python и Django.

### Установка IPython и django-extensions

Для начала установите необходимые пакеты через pip:

```bash
pip install ipython django-extensions
```

### Настройка django-extensions

Добавьте `django_extensions` в список `INSTALLED_APPS` в вашем файле `settings.py` проекта Django:

```python
INSTALLED_APPS = [
    ...
    'django_extensions',
]
```

### Использование shell_plus

`shell_plus` автоматически импортирует все модели вашего проекта при запуске, что упрощает работу с данными. Чтобы запустить `shell_plus`, используйте следующую команду:

```bash
python manage.py shell_plus
```

Если вы хотите видеть SQL-запросы, генерируемые вашими операциями с моделями в реальном времени, используйте флаг `--print-sql`:

```bash
python manage.py shell_plus --print-sql
```

### Пример работы в IPython с Django

После запуска `shell_plus` с `ipython`, вы можете воспользоваться преимуществами улучшенного автодополнения и интерактивности. Например, добавление новой записи в модель `User`:

```python
user = User(FirstName="John Doe")
user.save()
```

Если вы использовали `--print-sql`, то сразу после выполнения операции увидите SQL-запрос, который был отправлен в базу данных. Это помогает понять, как Django преобразует операции с моделями в SQL-запросы, и оптимизировать их при необходимости.

### `bulk_create` - это метод Django для создания несколько объектов модели

`bulk_create` - это метод Django, который позволяет создавать несколько объектов модели и сохранять их в базе данных одним запросом. Он полезен, когда нужно добавить большое количество записей в базу данных, так как это гораздо более эффективно, чем сохранение каждой записи отдельно.

Пример использования `bulk_create`:

```python
# Создание списка объектов для добавления в базу данных
new_records = [
    NewTable(field1='value1', field2=1),
    NewTable(field1='value2', field2=2),
    # Добавьте другие объекты по необходимости
]

# Добавление списка объектов в базу данных
NewTable.objects.bulk_create(new_records)
```

В данном примере создается список объектов `new_records`, содержащий два объекта модели `NewTable`. Затем метод `bulk_create` вызывается на менеджере модели `NewTable.objects` с этим списком объектов. В результате все записи из списка будут добавлены в базу данных одним SQL-запросом.

Это особенно полезно при работе с большими объемами данных, так как сокращает количество запросов к базе данных и улучшает производительность.

Что касается использования `bulk_create` в оболочке Django shell, то да, вы можете использовать его так же, как и другие методы моделей. Просто импортируйте соответствующую модель и вызовите метод `bulk_create` на ее менеджере объектов.

### Выводы

- Использование `ipython` и `django-extensions` значительно улучшает возможности стандартной оболочки Django, делая разработку более удобной и эффективной.
- `shell_plus` автоматически импортирует все модели и предоставляет улучшенные возможности для работы с ними, включая визуализацию SQL-запросов в реальном времени с помощью `--print-sql`.
- Эти инструменты особенно полезны для разработки и отладки, поскольку позволяют лучше понять взаимодействие между Django ORM и базой данных, а также оптимизировать производительность приложения.

## Работа в shell_plus

Давайте разберемся с работой с Django ORM (Object-Relational Mapping) через Django Shell Plus, а также как использовать некоторые базовые методы для работы с данными в моделях Django.

### Запуск Django Shell Plus
Django Shell Plus является частью пакета `django-extensions`, который обогащает стандартную оболочку Django новыми возможностями, включая автоматический импорт всех моделей и других удобных инструментов для работы с данными.

Чтобы запустить Shell Plus, используйте команду:
```bash
python manage.py shell_plus
```

### Работа с Моделями и Менеджерами
Каждая модель Django по умолчанию имеет объект менеджера, доступный через атрибут `.objects`. Этот менеджер позволяет выполнять запросы к базе данных для создания, получения, фильтрации и удаления записей.

#### Создание Записи
Чтобы создать новую запись, используйте метод `.create()` менеджера:
```python
user = User.objects.create(FirstName='John Doe')
```
После создания объекта его `pk` (primary key) можно проверить так:
```python
print(user.pk)
```

#### Чтение Данных
Для получения всех записей используйте метод `.all()`:
```python
users = User.objects.all()
```

Добавление метода `__str__` в модель позволяет изменить представление объектов при печати их на экран или в консоли:
```python
class User(models.Model):
    # поля модели
    def __str__(self):
        return self.FirstName
```
После добавления метода `__str__`, для того чтобы изменения вступили в силу в Shell Plus, оболочку необходимо перезапустить.

#### Фильтрация Записей
Метод `.filter()` используется для фильтрации записей по определенным условиям:
```python
filtered_users = User.objects.filter(FirstName='John Doe')
```

#### Получение Отдельной Записи
Для получения одной записи по условию используется `.get()`:
```python
specific_user = User.objects.get(pk=1) # Получение пользователя с ID=1
```

#### Ленивая Загрузка и Срезы
Django ORM использует ленивую загрузку данных, что означает, что запрос к базе данных выполняется только в момент обращения к данным:
```python
users = User.objects.all()[:3] # Запрос не выполнился
for user in users: # Запрос выполняется здесь, когда мы пытаемся получить данные
    print(user)
```

### SQL Запросы в Shell Plus
Shell Plus в сочетании с `django-extensions` позволяет просматривать SQL запросы, выполняемые ORM, что очень полезно для отладки и оптимизации запросов к базе данных.

Эти примеры демонстрируют базовые операции CRUD (создание, чтение, обновление, удаление) в Django ORM и как использовать Django Shell Plus для упрощения и ускорения разработки.

## Lookup в Shell Plus Django 4.2

Давайте разберем использование лукапов (lookups) в Django для расширенных запросов к базе данных, а также познакомимся с некоторыми специфическими методами фильтрации.

Что же это такое? Это префиксы и постфиксы к названиям наших атрибутов

Лукапы (lookups) в Django позволяют нам выполнять более сложные запросы к базе данных, фильтровать данные и получать нужные нам результаты.

Префиксы и постфиксы лукапов добавляются к названиям атрибутов моделей или полей в запросах. Они указывают на то, как должны быть обработаны значения при выполнении запроса.

Например, если у нас есть модель `User` с полем `name`, мы можем использовать лукап `icontains` для выполнения регистронезависимого поиска имени пользователя:

```python
from django.contrib.auth.models import User

users = User.objects.filter(name__icontains='john')
```

В данном примере `name__icontains` является лукапом. Префикс `i` означает, что поиск должен быть регистронезависимым, а постфикс `contains` указывает на то, что значение поля должно содержать заданную подстроку.

Django предоставляет множество различных лукапов для разных типов полей и операций. Некоторые из них:

#таблица

| Lookup      | Описание                                                                                                                                     | Пример использования                                             |
| ----------- | -------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- |
| exact       | Возвращает объекты, у которых значение указанного поля точно совпадает с заданным значением.                                                 | User.objects.filter(FirstName__exact='John')                     |
| iexact      | Возвращает объекты, у которых значение указанного поля точно совпадает с заданным значением без учета регистра.                              | User.objects.filter(FirstName__iexact='john')                    |
| contains    | Возвращает объекты, у которых значение указанного поля содержит заданную подстроку.                                                          | Card.objects.filter(question__contains='python')                 |
| icontains   | Возвращает объекты, у которых значение указанного поля содержит заданную подстроку без учета регистра.                                       | Card.objects.filter(question__icontains='Python')                |
| in          | Возвращает объекты, у которых значение указанного поля находится в списке заданных значений.                                                 | User.objects.filter(UserID__in=[1, 2, 3])                        |
| gt          | Возвращает объекты, у которых значение указанного поля больше заданного значения.                                                            | Card.objects.filter(views__gt=100)                               |
| gte         | Возвращает объекты, у которых значение указанного поля больше или равно заданному значению.                                                  | Card.objects.filter(views__gte=100)                              |
| lt          | Возвращает объекты, у которых значение указанного поля меньше заданного значения.                                                            | Card.objects.filter(views__lt=100)                               |
| lte         | Возвращает объекты, у которых значение указанного поля меньше или равно заданному значению.                                                  | Card.objects.filter(views__lte=100)                              |
| startswith  | Возвращает объекты, у которых значение указанного поля начинается с заданной подстроки.                                                      | User.objects.filter(FirstName__startswith='J')                   |
| istartswith | Возвращает объекты, у которых значение указанного поля начинается с заданной подстроки без учета регистра.                                   | User.objects.filter(FirstName__istartswith='j')                  |
| endswith    | Возвращает объекты, у которых значение указанного поля заканчивается на заданную подстроку.                                                  | User.objects.filter(FirstName__endswith='n')                     |
| iendswith   | Возвращает объекты, у которых значение указанного поля заканчивается на заданную подстроку без учета регистра.                               | User.objects.filter(FirstName__iendswith='N')                    |
| range       | Возвращает объекты, у которых значение указанного поля находится в заданном диапазоне.                                                       | Card.objects.filter(views__range=(100, 200))                     |
| date        | Возвращает объекты, у которых значение указанного поля является датой, равной заданной дате.                                                 | Card.objects.filter(upload_date__date=datetime.date(2022, 1, 1)) |
| year        | Возвращает объекты, у которых значение указанного поля является годом, равным заданному году.                                                | Card.objects.filter(upload_date__year=2022)                      |
| month       | Возвращает объекты, у которых значение указанного поля является месяцем, равным заданному месяцу.                                            | Card.objects.filter(upload_date__month=1)                        |
| day         | Возвращает объекты, у которых значение указанного поля является днем, равным заданному дню.                                                  | Card.objects.filter(upload_date__day=1)                          |
| week_day    | Возвращает объекты, у которых значение указанного поля является днем недели, равным заданному дню недели. (0 - понедельник, 6 - воскресенье) | Card.objects.filter(upload_date__week_day=0)                     |
| isnull      | Возвращает объекты, у которых значение указанного поля является NULL или не NULL.                                                            | Card.objects.filter(answer__isnull=True)                         |
| regex       | Возвращает объекты, у которых значение указанного поля соответствует заданному регулярному выражению.                                        | Card.objects.filter(question__regex=r'^[A-Za-z]+$')              |

## Примеры `Lookup` запросов

Для создания примеров запросов с использованием lookup-ов в Django ORM для вашей базы данных, давайте начнем с простых и постепенно перейдем к более сложным. Эти запросы помогут вам взаимодействовать с вашей моделью данных для `Card`, `Category`, `Tag`, и `CardTags`.

1. **Получить все карточки**:
   ```python
   Card.objects.all()
   ```
   Этот запрос возвращает все объекты модели `Card`.

2. **Получить карточку по ее ID**:
   ```python
   Card.objects.get(card_id=1)
   ```
   Получает карточку с определенным `card_id`.

3. **Получить карточки с определенным количеством просмотров**:
   ```python
   Card.objects.filter(views=100)
   ```
   Ищет карточки, которые были просмотрены ровно 100 раз.

4. **Получить карточки, которые были добавлены после определенной даты**:
   ```python
   Card.objects.filter(upload_date__gt='2024-01-01')
   ```
   Использует `__gt` (greater than) для фильтрации карточек, добавленных после 1 января 2024 года.

5. **Получить карточки с количеством просмотров больше 50**:
   ```python
   Card.objects.filter(views__gt=50)
   ```
   Использует `__gt` для поиска карточек с более чем 50 просмотрами.

6. **Получить категории по части имени**:
   ```python
   Category.objects.filter(name__icontains='history')
   ```
   Использует `__icontains` для поиска категорий, содержащих "history" в имени, без учета регистра.

7. **Получить карточки с любым тегом из списка**:
   ```python
   Card.objects.filter(tags__name__in=['tag1', 'tag2'])
   ```
   Использует `__in` для фильтрации карточек, которые имеют теги с именами "tag1" или "tag2".

8. **Получить карточки, которые имеют более одного тега**:
   ```python
   Card.objects.annotate(num_tags=Count('tags')).filter(num_tags__gt=1)
   ```
   Аннотирует количество тегов каждой карточки и фильтрует те, у которых больше одного тега.

9. **Получить карточки с тегами, отсортированными по имени**:
   ```python
   Card.objects.prefetch_related(Prefetch('tags', queryset=Tag.objects.order_by('name')))
   ```
   Использует `Prefetch` для оптимизации запроса и получения карточек с тегами, отсортированными по имени.

10. **Получить карточки, у которых категория равна 'Science'**:
    ```python
    Card.objects.filter(category_id__name='Science')
    ```
    Использует связь через `__` для фильтрации карточек по имени категории.

11. **Получить все уникальные категории карточек**:
    ```python
    Category.objects.filter(card__isnull=False).distinct()
    ```
    Возвращает все уникальные категории, которые используются хотя бы в одной карточке.

12. **Получить теги, используемые в карточках, и количество таких карточек для каждого тега**:
    ```python
    Tag.objects.annotate(num_cards=Count('cards')).order_by('-num_cards')
    ```
    Аннотирует количество карточек, связанных с каждым тегом, и сортирует теги по убыванию этого числа.

13. **Получить карточки, у которых нет тегов**:
    ```python
    Card.objects.filter(tags__isnull=True)
    ```
    Использует `__isnull` для фильтрации карточек без тегов.

14. **Получить карточки, добавленные в последние 7 дней**:
    ```python
    from django.utils import timezone
    Card.objects.filter(upload_date__gte=timezone.now() - timezone.timedelta(days=7))
    ```
    Фильтрует карточки, добавленные за последние 7 дней, используя `timezone`.

15. **Получить карточки с тегом, имя которого начинается на "A"**:
    ```python
    Card.objects.filter(tags__name__startswith='A')
    ```
    Использует `__startswith` для фильтрации карточек по началу имени тега.

16. **Получить количество просмотров у всех карточек в категории "Science"**:
    ```python
    Card.objects.filter(category_id__name="Science").aggregate(total_views=Sum('views'))
    ```
    Использует `aggregate` с функцией `Sum` для подсчета общего количества просмотров карточек в категории "Science".

17. **Получить карточки, у которых количество просмотров находится в определенном диапазоне**:
    ```python
    Card.objects.filter(views__range=(50, 100))
    ```
    Фильтрует карточки с количеством просмотров между 50 и 100 включительно.

18. **Получить карточки, у которых имя категории заканчивается на "y"**:
    ```python
    Card.objects.filter(category_id__name__endswith='y')
    ```
    Использует `__endswith` для поиска карточек, чья категория заканчивается на "y".

19. **Получить карточки, отсортированные по убыванию даты добавления и количеству просмотров**:
    ```python
    Card.objects.order_by('-upload_date', '-views')
    ```
    Сортирует карточки сначала по дате добавления, затем по количеству просмотров, оба в убывающем порядке.

20. **Получить карточки с самым популярным тегом (тег с наибольшим количеством карточек)**:
    ```python
    most_popular_tag = Tag.objects.annotate(num_cards=Count('cards')).order_by('-num_cards').first()
    Card.objects.filter(tags=most_popular_tag)
    ```
    Сначала определяет самый популярный тег (с наибольшим количеством связанных карточек), затем фильтрует карточки, которые связаны с этим тегом.

Эти примеры демонстрируют разнообразие возможностей Django ORM для работы с данными. Использование различных lookup-ов позволяет точно и гибко запросить нужные данные из вашей базы.

### Метод `get`

Метод `get` используется для получения одной конкретной записи. Важно, что если записей не найдено или найдено больше одной, метод `get` вызовет исключение:

```python
try:
    user = User.objects.get(UserID=1)  # Попытка получить пользователя с UserID=1
except User.DoesNotExist:
    print("Пользователь не найден")
except User.MultipleObjectsReturned:
    print("Найдено более одного пользователя")
```

### Заключение

Эти примеры демонстрируют, как использовать различные лукапы и методы для фильтрации, исключения и получения записей из базы данных в Django. Лукапы и методы фильтрации мощные инструменты Django ORM, позволяющие выполнять сложные запросы к базе данных с минимальным количеством кода.

## Сортировка

Давайте разберемся, как работать с моделями Django и осуществлять сортировку записей в базе данных, используя Django ORM (Object-Relational Mapping). В нашем примере у нас есть две таблицы: `Cards` и `Users`.

### Шаг 1: Определение моделей Django

Для начала необходимо определить модели в Django, которые соответствуют нашим таблицам в базе данных. Предположим, что вы уже создали приложение в вашем проекте Django. Теперь в файле `models.py` вашего приложения определите следующие модели:

```python
from django.db import models

class User(models.Model):
    FirstName = models.CharField(max_length=100)

    def __str__(self):
        return self.FirstName

class Card(models.Model):
    question = models.TextField()
    answer = models.TextField()
    user = models.ForeignKey(User, on_delete=models.CASCADE, default=1)
    upload_date = models.DateTimeField(auto_now_add=True)
    views = models.IntegerField(default=0)
    adds = models.IntegerField(default=0)

    def __str__(self):
        return self.question
```

### Шаг 2: Создание миграций и обновление базы данных

После определения моделей необходимо создать миграции и применить их к базе данных:

```shell
python manage.py makemigrations
python manage.py migrate
```

### Шаг 3: Использование Django Shell Plus

Чтобы запустить оболочку Django с возможностью просмотра SQL команд, используйте Django Extension's `shell_plus`:

```shell
python manage.py shell_plus --print-sql
```

### Сортировка записей

Чтобы отсортировать карточки (`Cards`) по вопросу (`question`), вы можете использовать метод `order_by`:

```python
# Сортировка по возрастанию
cards_ascending = Card.objects.all().order_by('question')

# Сортировка по убыванию
cards_descending = Card.objects.all().order_by('-question')
```

Если вам нужно предварительно отфильтровать записи, а затем отсортировать их, используйте следующий код:

```python
# Фильтрация по пользователю с ID=1 и сортировка по вопросу по возрастанию
filtered_cards = Card.objects.filter(user_id=1).order_by('question')
```

### Сортировка по умолчанию в модели

Вы можете задать сортировку по умолчанию в классе `Meta` внутри вашей модели:

```python
class Card(models.Model):
    # поля модели
    class Meta:
        ordering = ['question']  # Сортировка по вопросу по возрастанию
```

>[!info] Полезные ссылки
[Документация по классу Meta в моделях Django](https://docs.djangoproject.com/en/4.2/ref/models/options/#ordering).

### Добавление индексов к полям модели

Чтобы сделать поля `question` и `answer` индексированными (что может ускорить поиск по этим полям), добавьте параметр `db_index=True` к этим полям в определении модели:

```python
class Card(models.Model):
    question = models.TextField(db_index=True)
    answer = models.TextField(db_index=True)
    # остальные поля модели
```

После изменения моделей не забудьте создать и применить новые миграции:

```shell
python manage.py makemigrations
python manage.py migrate
```

Проверка сортировки по умолчанию:
```python
# Просто получите все объекты Card, и они будут отсортированы по 'question'
cards = Card.objects.all()
for card in cards:
    print(card.question)
```

Таким образом, вы можете управлять сортировкой записей в вашем приложении Django, используя ORM для более удобной работы с базой данных.

## Обновление и удаление записей

Для работы с моделями Django в оболочке, включая просмотр SQL-команд, выполнение сортировок, обновлений, и удалений записей, следуйте инструкциям ниже. Эти шаги предполагают, что вы уже создали модели `Card` и `User` в Django, соответствующие вашим таблицам `Cards` и `Users`.

### Запуск Django Shell Plus

Чтобы запустить оболочку Django с возможностью просмотра SQL-команд, используйте `django-extensions`:

1. Убедитесь, что `django-extensions` установлены в вашем проекте. Если нет, установите их с помощью pip:
   ```
   pip install django-extensions  
    ```
2. Добавьте `'django_extensions'` в `INSTALLED_APPS` вашего `settings.py` файла:
   ```python
   INSTALLED_APPS = [
       ...
       'django_extensions',
   ]
   ```

3. Запустите оболочку с помощью команды:
   ```
   python manage.py shell_plus --print-sql
   ```

### Выборка и сортировка записей

Чтобы выбрать карточку с первичным ключом (pk) 1 и отсортировать записи по вопросу, используйте следующие команды в оболочке:

```python
# Выборка карточки с pk = 1
card = Card.objects.get(pk=1)

# Сортировка всех карточек по полю 'question'
cards_sorted = Card.objects.all().order_by('question')

# Для сортировки по убыванию добавьте префикс '-' к имени поля
cards_sorted_desc = Card.objects.all().order_by('-question')
```

### Изменение записи

Чтобы изменить вопрос и ответ у карточки:

```python
card.question = 'Новый вопрос'
card.answer = 'Новый ответ'
card.save()  # Сохраняем изменения в базе данных
```

### Обновление нескольких записей

Чтобы установить поле `views` равным 1 для всех записей:

```python
Card.objects.all().update(views=1)
```

### Фильтрация и обновление для первых 10 записей

Django не поддерживает обновление среза записей напрямую через ORM. Вместо этого используйте фильтр с условием, например, через `pk`. Если у вас есть условие для выбора первых 10 записей, вы можете сделать что-то вроде:

```python
# Предполагаем, что у нас есть способ определить pk первых 10 записей
pks = Card.objects.all().order_by('pk')[:10].values_list('pk', flat=True)
Card.objects.filter(pk__in=list(pks)).update(views=2)
```

### Удаление записей

Чтобы удалить запись, сначала её нужно выбрать, а затем вызвать метод `delete()`:

```python
# Удаление конкретной записи
card_to_delete = Card.objects.get(pk=1)
card_to_delete.delete()

# Удаление всех записей, где views = 2
Card.objects.filter(views=2).delete()
```

Эти команды позволят вам управлять данными в вашей базе данных Django прямо из оболочки, используя Django ORM.


## Первое представление с БД (ищем по ID)

В Django, функция `get_object_or_404` используется для того, чтобы получить объект из базы данных по определённым критериям или вернуть ошибку 404 (объект не найден), если такой объект не существует. Это полезно для создания веб-страниц, которые зависят от наличия конкретных данных в базе данных. Если данные отсутствуют, пользователю показывается стандартная страница с ошибкой 404, что лучше, чем возникновение исключения и показ пользователю страницы с ошибкой сервера.

### Использование get_object_or_404

Чтобы использовать `get_object_or_404`, вам необходимо сначала импортировать её из модуля `django.shortcuts`:

```python
from django.shortcuts import get_object_or_404
```

Теперь, используя эту функцию, мы можем переписать вашу функцию `get_detail_card_by_id` для работы с базой данных вместо словаря `cards_dataset`.

Предположим, что у вас есть модель `Card`, соответствующая таблице `Cards` в вашей базе данных:

```python
from django.db import models

class Card(models.Model):
    question = models.TextField()
    answer = models.TextField()
    user = models.ForeignKey('User', on_delete=models.CASCADE, default=1)
    upload_date = models.DateTimeField(auto_now_add=True)
    views = models.IntegerField(default=0)
    adds = models.IntegerField(default=0)
```

И вот как может выглядеть обновлённая функция `get_detail_card_by_id`, которая теперь получает объект `Card` из базы данных:

```python
from django.shortcuts import render, get_object_or_404
from .models import Card

def get_detail_card_by_id(request, card_id):
    """
    Возвращает шаблон cards/templates/cards/card_detail.html с детальной информацией по карточке
    """
    # Получаем карточку по ID или возвращаем 404
    card_by_id = get_object_or_404(Card, pk=card_id)

    context = {
        "card": card_by_id
    }
    return render(request, 'cards/card_detail.html', context)
```

В этом примере, если карточка с указанным `card_id` не найдена, Django автоматически отправит пользователю ответ HTTP 404.

### Запуск сервера и тестирование

Для запуска Django-проекта используйте команду:

```
python manage.py runserver
```

Теперь, если вы перейдёте по URL, который соответствует вашей функции `get_detail_card_by_id` (например, `http://localhost:8000/cards/1/` для карточки с `id=1`), вы увидите страницу с деталями карточки или страницу с ошибкой 404, если такой карточки нет.

### Важные моменты

- `get_object_or_404` значительно упрощает процесс получения объектов из базы данных и обработки случаев, когда объект не найден.
- При использовании `get_object_or_404` важно помнить, что она работает с любым QuerySet, что означает, что вы можете использовать её не только для получения объектов по `pk`, но и для выполнения более сложных запросов с фильтрацией.
- Эта функция является частью Django "из коробки" и не требует дополнительной настройки для своего использования.

## Второе представление с БД (обрабатываем `GET` запросы)

Мы можем написать функцию представления так, чтобы она могла обрабатывать 0, 1 или 2 параметра `GET` запроса и возвращала соответствующий ответ. Если ни один из ожидаемых параметров (`OrderBy` или `Limit`) не передан, функция должна возвращать сообщение об отсутствии необходимых параметров. Давайте перепишем вашу функцию, оптимизируя её логику:

```python
from django.http import HttpResponse

def catalog2(request):
    """
    Экспериментальный каталог под GET запросы.
    Отдаём в ответе все параметры GET запроса или сообщение об отсутствии ожидаемых параметров.
    :param request:
    :return: HttpResponse
    """
    # Получаем значения параметров 'OrderBy' и 'Limit' из GET запроса
    order_by = request.GET.get('OrderBy')
    limit = request.GET.get('Limit')

    # Строим ответ в зависимости от переданных параметров
    response_text = []

    if order_by:
        response_text.append(f'Сортировка по {order_by}')
    if limit:
        response_text.append(f'Лимит: {limit}')

    # Если были переданы ожидаемые параметры, объединяем их в одну строку и возвращаем
    if response_text:
        return HttpResponse('. '.join(response_text))

    # Если ожидаемые параметры не были переданы, возвращаем сообщение об ошибке
    return HttpResponse('Ожидаемые параметры не переданы. Необходимо передать параметры для сортировки (OrderBy) или лимита (Limit).', status=404)
```

В этой версии функции мы создаём пустой список `response_text`, в который добавляем строки с описанием выполненных действий в зависимости от наличия параметров `OrderBy` и `Limit`. Если список не пустой (то есть был передан хотя бы один параметр), мы объединяем все строки в одну с помощью метода `.join()` и возвращаем её в ответе. Если ни одного ожидаемого параметра не было передано, возвращаем сообщение об ошибке с HTTP-статусом 404.

Этот подход позволяет гибко обрабатывать различные комбинации параметров и возвращать соответствующие сообщения, делая код функции более читаемым и легко расширяемым.

Давайте детально разберем предыдущий код и рассмотрим, как бы запросы Django ORM к модели `Card` могли быть интегрированы в него для реализации логики сортировки и лимита выводимых карточек.

### Анализ кода функции `catalog2`

Функция `catalog2` предназначена для обработки GET-запросов, поступающих на определенный URL вашего веб-приложения на Django. Она извлекает параметры `OrderBy` и `Limit` из запроса, если они присутствуют, и возвращает соответствующий HTTP-ответ.

- **Извлечение параметров из GET-запроса**: 
  - `order_by = request.GET.get('OrderBy')` ищет в GET-запросе параметр `OrderBy`. Если такой параметр есть, переменная `order_by` будет содержать его значение. Этот параметр предполагается использовать для указания поля модели `Card`, по которому должна происходить сортировка карточек (например, `views` или `upload_date`).
  - `limit = request.GET.get('Limit')` выполняет аналогичную операцию для параметра `Limit`, который определяет максимальное количество карточек, отображаемых на странице.

- **Построение ответа**: В зависимости от того, какие параметры были переданы в запросе, функция формирует строку ответа, добавляя в нее информацию о сортировке и/или лимите. Если не было передано ни одного из ожидаемых параметров, функция возвращает сообщение об ошибке с HTTP-статусом 404.

### Интеграция запросов Django ORM

Для интеграции логики работы с моделью `Card` в функцию `catalog2`, можно использовать запросы Django ORM для фильтрации, сортировки и ограничения количества карточек, отображаемых пользователю.

1. **Сортировка (`OrderBy`)**: 
   Используйте Django ORM для сортировки объектов модели `Card` в соответствии с параметром `order_by`. Например, если `order_by` равно `views`, запрос к базе данных должен возвращать карточки, отсортированные по количеству просмотров.
   
   ```python
   if order_by in ['question', 'upload_date', 'views', 'adds']:
       cards = Card.objects.all().order_by(order_by)
   ```

2. **Лимитирование вывода (`Limit`)**:
   Ограничьте количество возвращаемых карточек, используя переданный параметр `Limit`. Это можно сделать с помощью среза QuerySet.
   
   ```python
   if limit:
       try:
           limit = int(limit)
           cards = cards[:limit]
       except ValueError:
           # Обработка случая, когда Limit не является целым числом
           return HttpResponse('Ошибка: параметр Limit должен быть целым числом.', status=400)
   ```

3. **Возвращение результата**:
   После применения фильтров сортировки и лимита, вы можете сериализовать полученные объекты `Card` в формат HTML (или JSON, если создаете API) и включить их в HTTP-ответ.

Обратите внимание, что в этом примере используется дополнительная проверка на наличие поля `order_by` среди атрибутов модели `Card`, чтобы избежать ошибок и потенциальных уязвимостей, связанных с некорректными параметрами сортировки. Также обрабатывается случай, когда `limit` не может быть преобразован в целое число.

Чтобы позволить пользователю выбирать разные типы сортировки и соответственно отдавать ему новые данные, можно использовать несколько подходов в Django. Один из самых распространенных способов — использование GET-параметров в URL для указания критериев сортировки и ограничения количества отображаемых элементов. Вот как это можно реализовать:

### Шаг 1: Создание ссылок для сортировки

В вашем шаблоне Django вы можете создать ссылки или кнопки, которые позволяют пользователю выбирать параметры сортировки. Каждая ссылка будет добавлять соответствующий GET-параметр к URL текущей страницы.

Пример ссылок для сортировки по дате загрузки, количеству просмотров и количеству добавлений:
```html
<a href="?OrderBy=upload_date">Сортировать по дате</a>
<a href="?OrderBy=views">Сортировать по просмотрам</a>
<a href="?OrderBy=adds">Сортировать по добавлениям</a>
```

### Шаг 2: Обработка параметров сортировки во view

Во view-функции (или view-классе) вы обрабатываете эти параметры, используя их для сортировки объектов модели `Card`. Вы извлекаете параметры сортировки из `request.GET` и применяете их при формировании запроса к базе данных.

```python
def catalog2(request):
    order_by = request.GET.get('OrderBy', 'upload_date')  # Значение по умолчанию, если параметр не указан
    limit = request.GET.get('Limit')

    # Получение объектов с применением сортировки
    cards = Card.objects.all().order_by(order_by)

    # Применение лимита, если он указан
    if limit:
        try:
            limit = int(limit)
            cards = cards[:limit]
        except ValueError:
            # Обработка некорректного значения Limit
            pass

    # Отображение шаблона с передачей отфильтрованных и отсортированных карточек
    return render(request, 'cards/catalog.html', {'cards': cards})
```

### Шаг 3: Отображение результатов в шаблоне

В шаблоне `catalog.html` вы итерируете по отсортированным и отфильтрованным объектам `cards` и отображаете их. Также не забывайте включить в шаблон созданные ранее ссылки для сортировки, чтобы пользователь мог выбирать параметры сортировки прямо со страницы.

### Дополнительные возможности

- **Сохранение текущих параметров сортировки при переключении**: Если на странице есть и другие параметры (например, фильтры по категориям), вы можете добавить текущие параметры сортировки к ссылкам для этих фильтров, чтобы при их использовании сохранялись выбранные параметры сортировки.
- **Использование JavaScript**: Для более интерактивного пользовательского интерфейса можно использовать JavaScript для отправки запросов сортировки без перезагрузки страницы, используя AJAX.

Эти шаги позволят создать гибкую систему сортировки, которая улучшит пользовательский опыт на вашем сайте, позволяя легко изменять порядок отображения карточек в соответствии с предпочтениями пользователя.

### Итоговая вьюшка

```python
from django.shortcuts import render
from .models import Card

def card_catalog(request):
    sort_option = request.GET.get('order_by', 'newest')
    sort_order = request.GET.get('direction', 'desc')
    cards_query = Card.objects.all()

    # Определение ключа сортировки в зависимости от параметра sort_option
    if sort_option == 'popularity':
        sort_key = '-views' if sort_order == 'desc' else 'views'
    elif sort_option == 'activity':
        sort_key = '-adds' if sort_order == 'desc' else 'adds'
    elif sort_option == 'newest':
        sort_key = '-upload_date'  # Сортировка по новизне всегда в обратном порядке
    else:  # Если передан неизвестный параметр, сортируем по дате добавления по умолчанию
        sort_key = 'upload_date' if sort_order == 'asc' else '-upload_date'

    sorted_cards = cards_query.order_by(sort_key)
    return render(request, 'cards/catalog.html', {'cards': sorted_cards})
```

### Как это работает

1. **Импорты:**
   - `render`: Функция Django для рендеринга HTML-шаблона.
   - `Card`: Модель данных, представляющая карточку.

2. **Функция `card_catalog`:**
   - Это представление Django, которое обрабатывает запросы к странице каталога карточек.

3. **Получение параметров из GET-запроса:**
   - `sort_option` и `sort_order` получаются из параметров GET-запроса. Если параметры не указаны, используются значения по умолчанию (`'newest'` и `'desc'`, соответственно).

4. **Определение ключа сортировки:**
   - В зависимости от `sort_option`, определяется ключ, по которому будет производиться сортировка карточек. Например, если выбрана сортировка по популярности (`'popularity'`), ключом сортировки будет количество просмотров (`'views'`). Порядок сортировки (`'desc'` или `'asc'`) определяется параметром `sort_order`.

5. **Применение сортировки:**
   - С помощью метода `order_by` карточки сортируются по выбранному ключу. При использовании префикса `'-'` сортировка производится в обратном порядке.

6. **Рендеринг шаблона:**
   - С использованием функции `render` HTML-шаблон `catalog.html` рендерится с переданным контекстом, содержащим отсортированный список карточек (`{'cards': sorted_cards}`).

## Третье представление с БД - показать карточки по категории

Для вашего приложения карточек функция может выглядеть примерно так:

### Основные шаги функции

1. **Получение объекта категории**: Функция начинается с попытки получить категорию с определённым `slug`. Используется функция `get_object_or_404`, которая попытается найти объект `Category` с соответствующим `slug`. Если такой категории нет, пользователю покажется ошибка 404, сообщающая о том, что страница не найдена.

2. **Получение карточек категории**: Затем функция ищет все карточки, связанные с этой категорией. Это делается с помощью фильтрации `Card` по `category`, ссылающейся на `pk` (первичный ключ) найденной категории. Здесь используется менеджер `published`, который, вероятно, представляет собой пользовательский менеджер, возвращающий только опубликованные карточки.

3. **Формирование контекста**: Далее, формируется контекст для передачи в шаблон. Это словарь, который включает название категории, меню (вероятно, список всех категорий), карточки в выбранной категории и идентификатор выбранной категории.

4. **Отображение страницы**: Наконец, сформированный контекст отправляется в шаблон `women/index.html` с помощью функции `render`. В результате, пользователь увидит страницу с карточками выбранной категории.

### Нагрузка на базу данных

Если вы не выбрали категории заранее, ваша функция может выполнять дополнительные запросы к базе данных. В Django запросы к базе данных обычно ленивые, то есть они не выполняются до тех пор, пока не понадобятся конкретные данные. Но если в процессе работы функции вы часто обращаетесь к базе данных без необходимости (например, если каждый раз при рендеринге страницы вы заново получаете список категорий или карточек), это может привести к ненужной нагрузке на базу данных и замедлению работы приложения.

Чтобы уменьшить количество запросов, вы можете использовать методы `select_related` и `prefetch_related`, которые позволяют загрузить связанные данные заранее и избежать лишних запросов. Это особенно важно, когда вы работаете с большим количеством связанных данных.

В вашем случае, если `menu` в контексте представляет собой список всех категорий, стоит подумать о кэшировании этого списка, чтобы избежать его повторного получения при каждом запросе страницы. Это может быть реализовано на уровне шаблона, на уровне представления или с помощью системы кэширования Django.

```python
def show_category_cards(request, cat_slug):
    # Получение категории по slug. Если категория не найдена, возвращается ошибка 404.
    category = get_object_or_404(Category, slug=cat_slug)

    # Получение всех карточек, относящихся к данной категории.
    cards = Card.objects.filter(category=category).all()

    # Подготовка данных для передачи в шаблон.
    data = {
        'title': f'Категория: {category.name}',
        'cards': cards,
        'category_selected': category.pk,
    }

    # Рендеринг страницы с переданным контекстом.
    return render(request, 'cards/category_view.html', context=data)
```

В этом коде:

- `cat_slug` – это slug категории, который вы получаете из URL.
- `get_object_or_404` – функция Django, которая пытается получить объект категории по заданному slug. Если такой объект не существует, Django возвращает страницу с ошибкой 404.
- `Card.objects.filter(category=category).all()` – запрос, который получает все карточки для найденной категории.
- `data` – словарь контекста, который передается в шаблон для отображения.

Если бы категории не были предварительно выбраны, Django мог бы выполнять отдельный SQL-запрос для каждой карточки, чтобы определить её категорию, что создало бы дополнительную нагрузку на базу данных. Это объясняет важность эффективного использования методов `select_related` и `prefetch_related` для оптимизации запросов к базе данных.